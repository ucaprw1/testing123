import asdfimport h5py import numpy as npimport jsonimport matplotlib.pyplot as pltfrom dataclasses import dataclassfrom pathlib import Pathimport requestsimport osimport datetimefrom typing import Unionimport zipfilefrom skimage import transform@dataclassclass net:        def __post_init__(self):         pass                def query_isa(start_date, stop_date, instrument):                            if  datetime.datetime.strptime(start_date, '%Y-%m-%d') is False:             raise ValueError("Incorrect start date format, should be YYYY-MM-DD")                datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)                stop_date_0 = datetime.date.fromisoformat(stop_date)        start_date_0 =datetime.date.fromisoformat(start_date)                date_range = (stop_date_0 - start_date_0)        if date_range.days > 3:            raise ValueError('Date range should be 3 days or less.')        if stop_date_0 < start_date_0:            raise ValueError('Start date must be before stop date.')                if stop_date_0 > datetime.date.today():            raise ValueError('The stop date must be today or earlier.')                if instrument.lower() not in ['lir', 'manannan', 'fand' , 'ecne']:            raise ValueError('Invalid instrument, must be Lir, Manannan, Fand or Ecne')                    if type(instrument) != str:            raise TypeError('Instrument must be type string.')                if type(start_date) != str:            raise TypeError('Start date must be type string.')                if type(stop_date) != str:            raise TypeError('Stop date must be type string.')                                url = ('https://dokku-app.dokku.arc.ucl.ac.uk/isa-archive/query/?start_date=' + start_date + '&stop_date=' + stop_date + '&instrument='  + instrument)                getfilename = requests.get(url)                files_list = json.loads(getfilename.content)                filenames =  []        for file in files_list:            filenames.append(file.get('filename'))        return filenames    def download_isa(filename, save_dir=os.getcwd()):                        if type(filename) != str:            raise TypeError('Filename must be a string.')                save_dir = str(save_dir)        if type(save_dir) != str:            raise TypeError('Save directory must be a string or Path object')                if os.path.isdir(save_dir) == False:            raise ValueError('Input save directory does not exist.')            download_url = 'http://dokku-app.dokku.arc.ucl.ac.uk/isa-archive/download/?filename=' + filename        download_files = requests.get(download_url, allow_redirects=True)                    file_path = os.path.join(save_dir, filename)                    with open(file_path, 'wb') as output:            output.write(download_files.content)      class SatMap:    def __init__(self, data, date, instrument, observatory, resolution, time, xcoords, ycoords):        self.data = data        self.date = date        self.instrument = instrument        self.observatory = observatory        self.resolution = resolution        self.time = time        self.xcoords = xcoords        self.ycoords = ycoords    def __str__(self):        obs = self.observatory.upper()        ins = self.instrument.upper()        x_l = self.xcoords[0]        x_r = self.xcoords[1]        y_b = self.ycoords[0]        y_u = self.ycoords[1]        res = self.resolution        return f"{obs}/{ins}: ({x_l},{y_b}) - ({x_r}, {y_u}) {res} m /px"    def __add__(self, otherMap):        """adds satmaps"""        if self.instrument != otherMap.instrument:            raise Exception('can only add images from the same instrument')        if self.resolution != otherMap.resolution:            raise Exception('can only add images with the same resolution')        if self.date != otherMap.date:            raise Exception('can only add images taken on the same day')        oxmin, oxmax, oymin, oymax = global_coord(self, otherMap)        xdi, ydi, val, numx, numy = earth_to_pixel(self, otherMap, oxmin, oxmax, oymin, oymax)        new = np.zeros((numy,numx))        for i in range(len(xdi)):            p = xdi[i]            q = ydi[i]            new[q][p] = val[i]        cont = np.flip(new,axis=0)        return SatMap(cont, self.date, self.instrument, self.observatory, self.resolution, (self.time, otherMap.time), (oxmin,oxmax), (oymin,oymax))    def __sub__(self, otherMap):        """subtracts satmaps taken on different days to see changes"""        if self.instrument != otherMap.instrument:            raise Exception('can only subtract images from the same instrument')                if self.resolution != otherMap.resolution:            raise Exception('can only subtract images with the same resolution')        if self.date == otherMap.date:            raise Exception('can only subtract images taken on different days')        overlap_left, overlap_right, overlap_bottom, overlap_top = overlap_coords(self, otherMap)        overlap_height = max(0, (overlap_top-overlap_bottom))        overlap_width = max(0, (overlap_right-overlap_left))        overlap = overlap_height*overlap_width        #does this need to allow for some error tolerance        if overlap == 0:            raise Exception('can only subtract images that at least partially overlap')        oxmin, oxmax, oymin, oymax = overlap_coords(self, otherMap)        xdi, ydi, val, numx, numy = earth_to_pixel(self, otherMap, oxmin, oxmax, oymin, oymax)        new_a = np.zeros((numy,numx))        new_b = np.zeros((numy,numx))        for i in range(int(len(xdi)/2)):            p = xdi[i]            q = ydi[i]            new_a[q][p] = val[i]         new_satmap_a = np.flip(new_a, axis=0)        for i in range(int(len(xdi)/2), len(xdi)):            p = xdi[i]            q = ydi[i]            new_b[q][p] = val[i]         new_satmap_b = np.flip(new_b, axis=0)        output = new_satmap_a - new_satmap_b        return SatMap(output, (self.date, otherMap.date), self.instrument, self.observatory, self.resolution, (self.time, otherMap.time), (oxmin, oxmax), (oymin, oymax))    def meta(self):        dict = {            "date": self.date,            "instrument": self.instrument,            "observatory": self.observatory,            "resolution": self.resolution,            "time": self.time,            "xcoords": self.xcoords,            "ycoords": self.ycoords        }        print(dict)        return dict        raise NotImplementedError    def fov(self):            return (abs(self.xcoords[0]-self.xcoords[1]), abs(self.ycoords[0]-self.ycoords[1]))            #Add in adjusment to fov for when fov is not divisible by resolution                raise NotImplementedError                return ((self.xcoords[0]+self.xcoords[1])/2, (self.ycoords[0]+self.ycoords[1])/2)        raise NotImplementedError        def shape(self):        """not correct way of doing"""                return (int(self.fov()[0]/self.resolution), int(self.fov()[1]/self.resolution))        raise NotImplementedError    def mosaic(self, otherMap: 'SatMap', resolution=None, padding: bool = False) -> 'SatMap':                """padding needs to be added"""                if self.date != otherMap.date:            raise Exception('can only add images taken on the same day')        oxmin, oxmax, oymin, oymax = global_coord(self, otherMap)                         xdi, ydi, val, numx, numy = earth_to_pixel(self, otherMap, oxmin, oxmax, oymin, oymax, resolution)                 new = np.zeros((numy,numx))        for i in range(len(xdi)):            p = xdi[i]            q = ydi[i]            new[q][p] = val[i]        cont = np.flip(new,axis=0)        return SatMap(cont, self.date, self.instrument, self.observatory, self.resolution, (self.time, otherMap.time), (oxmin,oxmax), (oymin,oymax))        raise NotImplementedError        def visualise(self, save: bool = False, savepath: Union[Path, str] = os.path.dirname(__file__), **kwargs):        extent = [self.xcoords[0],self.xcoords[1],self.ycoords[0],self.ycoords[1]]        if np.shape(self.date) == () and np.shape(self.time) == ():            cmap = 'viridis'            dates = self.date.replace('-','')            times = self.time.replace(':','')                elif np.shape(self.date) == () and np.shape(self.time) != ():            cmap = 'viridis'            dates = self.date.replace('-','')            times = "-".join(str(x) for x in self.time)            times = times.replace(':','')        else:            cmap = 'seismic'            dates = " ".join(str(x) for x in self.date)            dates = dates.replace('-','')            dates = dates.replace(' ','-')            times = "-".join(str(x) for x in self.time)            times = times.replace(':','')        if kwargs == {}:            fname = f"{self.observatory.lower()}_{self.instrument.lower()}_{dates}_{times}.png"        if kwargs != {}:            fname = f"{self.observatory.lower()}_{self.instrument.lower()}_{dates}_{times}_{kwargs}.png"        if save == True:                        plt.imshow(np.flip(self.data, axis=0), extent = extent, origin='lower', cmap=cmap)            plt.savefig(os.path.join(savepath, fname))            plt.close()        elif save == False:            plt.imshow(np.flip(self.data, axis=0), extent = extent, origin='lower', cmap=cmap)            plt.show()                            def earth_to_pixel(sat, other, oxmin, oxmax, oymin, oymax, resolution=None):    """puts earth coords into bins to allow for conversion to pixels"""            if resolution:        resolution = resolution        else:        resolution = min(sat.resolution, other.resolution) #takes highest revolution        numx = round((oxmax - oxmin)/resolution)    numy = round((oymax - oymin)/resolution)    binsx = np.linspace(oxmin, oxmax - resolution, num=numx)    binsy = np.linspace(oymin, oymax - resolution, num=numy)        if sat.resolution != other.resolution:                if other.resolution > sat.resolution:            factor = int((other.resolution)/(sat.resolution))            other_scaled = transform.rescale(other.data, factor)                    other.data = other_scaled            other.resolution = int( other.resolution * (1/factor))                    else:            factor = int((sat.resolution)/(other.resolution))            sat_scaled = transform.rescale(sat.data, factor, cval=0, clip=True)            sat.data = sat_scaled            sat.resolution = sat.resolution * (1/factor)        else:        pass               satarr = np.reshape(dim3(sat), (-1,3))         otherarr = np.reshape(dim3(other), (-1,3))    totalarr = np.concatenate((satarr, otherarr))    xco, yco, val = [], [], []    for i in range(np.shape(totalarr)[0]):            xco.append(totalarr[i][0])            yco.append(totalarr[i][1])            val.append(totalarr[i][2])    xdi = np.digitize(xco, binsx)    xdi = xdi - 1    ydi = np.digitize(yco, binsy)    ydi = ydi - 1    return xdi, ydi, val, numx, numy    raise NotImplementedErrordef pixel_to_earth(pixelx, pixely, satmap):    """converts pixel coords to earth"""    coordx = pixelx * satmap.resolution + min(satmap.xcoords[0], satmap.xcoords[1]) + satmap.resolution/2    coordy = - pixely * satmap.resolution + max(satmap.ycoords[0], satmap.ycoords[1]) - satmap.resolution/2    return coordx, coordy    raise NotImplementedError    """converts pixel coords to earth"""    coordx = pixelx * satmap.resolution + min(satmap.xcoords[0], satmap.xcoords[1]) + satmap.resolution/2    coordy = - pixely * satmap.resolution + max(satmap.ycoords[0], satmap.ycoords[1]) - satmap.resolution/2    return coordx, coordy    raise NotImplementedErrordef dim3(satmap):    """converts satmap data to format (x, y, val) """    arr = np.zeros([satmap.shape()[1], satmap.shape()[0], 3])    for j in range(satmap.shape()[1]):        for i in range(satmap.shape()[0]):            arr[j][i][0], arr[j][i][1] = pixel_to_earth(i, j, satmap)            arr[j][i][2] = satmap.data[j][i]                 return arrdef global_coord(sm, othersm):    """computes global coordinate range for two satmaps"""    oxmin = min(sm.xcoords[0],othersm.xcoords[0])    oxmax = max(sm.xcoords[1],othersm.xcoords[1])    oymin = min(sm.ycoords[0],othersm.ycoords[0])    oymax = max(sm.ycoords[1],othersm.ycoords[1])    return oxmin, oxmax, oymin, oymaxdef overlap_coords(sm, othersm):    """computes coordinates of overlapping rectangle"""    x0, x1 = sm.xcoords[0], sm.xcoords[1]    x_dash0, x_dash1 = othersm.xcoords[0], othersm.xcoords[1]    y0, y1 = sm.ycoords[0], sm.ycoords[1]    y_dash0, y_dash1 = othersm.ycoords[0], othersm.ycoords[1]    x_left_overlap = max(x0, x_dash0) #overlap_left    x_right_overlap = min(x1, x_dash1) #overlap_right    y_bottom_overlap = max(y0, y_dash0) #overlap_bottom    y_top_overlap = min(y1, y_dash1) #overlap_top    return x_left_overlap, x_right_overlap, y_bottom_overlap, y_top_overlapdef get_satmap(filename):       '''can we use save_dir from net.isa_download which would be more efficient, rather than locate_file function cause that has to search whole computer'''        def locate_file(filename):                    file_locations = []        current_location = os.getcwd()           current_filepath = Path(current_location)        path = current_filepath        if len(path.parts) <=2:            num_of_dir = len(path.parts)        else:            num_of_dir = len(path.parts)-2        filename = str(filename)        for i in range(num_of_dir):            path = path.parent        start = path        for root, dirs, files in os.walk(start, topdown=True):            for name in files:                if name == filename:                    file_locations.append(os.path.abspath(os.path.join(root, name)))        if len(file_locations) == 0:            raise FileNotFoundError ('The filename provided can not be found on this computer.')        else:            file_path = file_locations[0]            selected_file_location = Path(file_path)        return selected_file_location    current_location = os.getcwd()    local_str_filepath_fname = os.path.join(current_location,str(filename))    local_filepath_fname = Path(local_str_filepath_fname)    if local_filepath_fname.is_file():        filepath = filename    else:            filepath = locate_file(filename)          if filename.endswith('.asdf'):        lir_data = asdf.open(filepath)        return SatMap(lir_data['data'], lir_data['date'], lir_data['instrument'], lir_data['observatory'], lir_data['resolution'], lir_data['time'], lir_data['xcoords'], lir_data['ycoords'])             if filename.endswith('.hdf5'):        manannan_data = h5py.File(filepath, 'r')         return SatMap(manannan_data['observation']['data'][()], manannan_data['observation'].attrs['date'], manannan_data['observation'].attrs['instrument'], manannan_data['observation'].attrs['observatory'], manannan_data['observation'].attrs['resolution'], manannan_data['observation'].attrs['time'], manannan_data['observation'].attrs['xcoords'], manannan_data['observation'].attrs['ycoords'])    if filename.endswith('.zip'):        #unzipped_files = zipfile.ZipFile(filename, 'r')       with zipfile.ZipFile(filepath) as archive:                      with archive.open('metadata.json') as metadata:               r_m = json.load(metadata)                          with archive.open('observation.npy') as observation:               r = np.load(observation)           return SatMap(r, r_m['date'], r_m['instrument'], r_m['observatory'], r_m['resolution'], r_m['time'], r_m['xcoords'], r_m['ycoords'])             